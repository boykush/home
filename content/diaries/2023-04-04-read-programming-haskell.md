+++
title = "「Programming in Haskell 2nd edition」を読んだ"
date = 2023-04-04
[taxonomies]
tags=["Read"]
+++

{{thumbnail(src="https://cdn.shopify.com/s/files/1/1634/7169/products/cover_530x.png?v=1564720482")}}

# はじめに

1年か2年ほど前に途中まで読んで以来、長いこと積読していたHaskell本を読了したので学びを書く。

特に15章以降が学びが多かったので14章以前は省略する。

[翻訳版書籍リンク](https://www.lambdanote.com/collections/haskell)

# 15章 遅延評価
Scala構文の `lazy val`や `monix.eval.Task`の利用等でどのような挙動とメリットがあるかざっくりは理解していたが、本章では評価戦略の種類から丁寧に比較と説明がされていて理解を深めることができた。

評価戦略は

- 最内簡約 → 値渡し
- 最外簡約 → 名前渡し

といった対応になる。

本章では遅延評価（名前渡し）によって無限リストを生み出す再帰関数の評価を停止させるサンプルコードが紹介されている。

ここでの学びは「データと制御の分離」という表現を得たこと。

この表現によって後続の章の内容も理解が進みやすい構成になっていた。

# 16章 プログラムの論証
本章では等式推論・数学的帰納法・構造的帰納法の紹介の後、最後にコンパイルの正しさを論証している。

コンパイルの正しさを論証する前に再帰データ型の基底部と再帰部それぞれを分けて証明する例題が紹介されていた。

コンパイルの正しさの論証に関して、自身は証明の式の適用を順に追っていくのがやっとだったが、数式（ソース言語）・コード・スタックの関係性を把握することができた。

# 17章 コンパイラーの算出
本章では「ソース言語」を「低レベルコード」と「実行する仮想マシン」の2つに変換する流れが解説されている。ここが正に15章の「データと制御の分離」という表現が適用できる箇所だった。

16章の論証での数式に続いて

- スタックの型化
- スタックのやり取りを継続渡しへと変換
- コンビネーターとコード型の定義による継続の脱高階関数

といった手順で算出が行われていく。

これまで簡単なインタプリタの実装コード等は読んだことがあったが、より理論的に？コンパイラについて理解を深めることができた

# 関数型プログラミングは低レイヤのデザインパターンを抽象化している？
17章まで読んで頭に浮かんだのが上記の問い。本書で解説されたような低レイヤに限らないとは思うが「データと制御の分離」を行うデザインパターンという新たな理解を得た。

普段触っているExtensible Effectを用いたatnos-effライブラリでも式として呼び出すコマンドの定義とインタプリタ実行が分離されている。技術的な関心事を独自エフェクトとして抽象化することで比較的簡単な記述で隠蔽された複雑な実装を利用することができる。

趣味として独自エフェクトを作成する作業はとても楽しかったが、新しいプログラミング言語を作る感覚に近かったのかもしれない。

思わぬアハ体験をしたのでついブログにまとめた。低レイヤの知識含めまだまだなので精進していきたい。
